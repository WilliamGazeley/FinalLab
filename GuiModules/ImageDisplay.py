#!/usr/bin/python
# -*- coding: utf-8 -*-

import configparser
import tkinter as Tk
from Data import DataManager

config = configparser.ConfigParser()
config.read('config.ini')
colourScheme = config['colourScheme']


class image:

    # @param parent is the parent of the image
    # @param data is an array of bytes
    # @param imgSizeX & imgSizeY are the dimensions of the image to be displayed

    def __init__(self, parent, path):

        # take data and use datamanager to return imageSize, and ints.

        # Attributes

        self.path = path
        self.imageNum = 0  # current image in the data to be viewed
        self.imgSize = DataManager.getImgSize(path, split=True)
        self.imgSizeX = self.imgSize[1]
        self.imgSizeY = self.imgSize[0]
        self.imgSize = DataManager.getImgSize(path, split=False)
        self.setSize = DataManager.getSetSize(path)  # Number of images in set
        self.currentPixel = None  # Tk.Frame obj
        self.currentPixelPos = None  # int position of pixel in current image

        # Pixel holder

        self.wrapper = Tk.Frame(parent)
        self.wrapper.grid(row=0, column=0)
        self.digitDisplay = Tk.Frame(self.wrapper, width=235,
                height=235)
        self.digitDisplay.grid_propagate(False)
        for i in range(self.imgSizeY):
            self.digitDisplay.grid_rowconfigure(i, weight=1)
        for i in range(self.imgSizeX):
            self.digitDisplay.grid_columnconfigure(i, weight=1)
        self.digitDisplay.grid(row=0, column=0)

        # EntryBox

        self.pixelLabel = Tk.Label(self.wrapper,
                                   text='No pixel selected')
        self.pixelLabel.grid(row=1, column=0, sticky='nswe')

        # self.pixel is a 2d array containing Tk.Frames. [0] = imageNum, [1] = frames

        pixel = []
        for i in range(self.setSize):
            pixel.append([])
            self.data = DataManager.getImage(self.path, i)
            for j in range(self.imgSizeX * self.imgSizeY):
                val = int.from_bytes(self.data[j:j + 1], byteorder='big'
                        )
                pixel[i].append(self.newPixel(val, j))

        self.pixel = pixel

        # Free up some ram

        self.data = None

        return

    # Replaces existing Image Display with a new one
    # @param data is an array of bytes
    # @param imgSizeX & imgSizeY are the dimensions of the image to be displayed

    def newImg(self, path):

        # Destroy old pixels

        for i in range(self.setSize):
            self.data = DataManager.getImage(self.path, i)
            for j in range(self.imgSizeX * self.imgSizeY):
                self.pixel[i][j].destroy()

        # New attributes

        self.path = path
        self.imageNum = 0  # current image in the data to be viewed
        self.imgSize = DataManager.getImgSize(path, split=True)
        self.imgSizeX = self.imgSize[1]
        self.imgSizeY = self.imgSize[0]
        self.imgSize = DataManager.getImgSize(path, split=False)
        self.setSize = DataManager.getSetSize(path)  # Number of images in set
        self.currentPixel = None  # Tk.Frame obj
        self.currentPixelPos = None  # int position of pixel in current image

        # self.pixel is a 2d array containing Tk.Frames. [0] = imageNum, [1] = frames

        pixel = []
        for i in range(self.setSize):
            pixel.append([])
            self.data = DataManager.getImage(self.path, i)
            for j in range(self.imgSizeX * self.imgSizeY):
                val = int.from_bytes(self.data[j:j + 1], byteorder='big'
                        )
                pixel[i].append(self.newPixel(val, j))

        self.pixel = pixel

        # Free up some ram

        self.data = None

        return

    # Returns an array of pixel values that make up an image

    def getImgData(self):
        data = DataManager.getImage(self.path, self.imageNum)
        return data.tolist()  # Convert to list to work around numpy bug

    # Returns a Tk.Frame object with colour (val,val,val)
    # @param val is an int32 representing the gamma of pixel
    # @para, pos is the position of the Pixel in self.pixel

    def newPixel(self, val, pos):
        gamma = '#' + ''.join('{:02x}'.format(val)) * 3

        # use highlightcolour to store gamma for deselecting pixel

        pixel = Tk.Frame(self.digitDisplay, bd=0, bg=gamma,
                         highlightcolor=gamma, cursor='hand2')
        pixel.bind('<Enter>', lambda x: self.highlight(pixel, pos))
        return pixel

    # Highlights the pixel under cursor
    # @param pixel is a Tk.Frame object generated by newPixel()
    # @param pos is the position of the pixel in self.pixel

    def highlight(self, pixel, pos):
        pixel.config(bg=colourScheme['btnDetail'])
        pixel.bind('<ButtonRelease>', lambda x: self.click(pixel, pos))
        pixel.bind('<Leave>', lambda x: self.unhighlight(pixel))
        return

    # Unhighlights the pixel when cursor leaves
    # @param pixel is a Tk.Frame object generated by newPixel()
    # @param pos is the position of the pixel in self.pixel

    def unhighlight(self, pixel):
        if pixel != self.currentPixel:
            pixel.config(bg=pixel['highlightcolor'])
        else:
            pixel.config(bg=colourScheme['btnAlt'])
        return

    # Highlights the pixel under cursor and sets the new current pixel
    # @param pixel is a Tk.Frame object generated by newPixel()
    # @param pos is the position of the pixel in self.pixel

    def click(self, pixel, pos):

        # restore colour of previous selected pixel

        if self.currentPixel != None:
            self.currentPixel.config(bg=self.currentPixel['highlightcolor'
                    ])

        # set new pixel

        pixel.config(bg=colourScheme['btnAlt'])
        self.currentPixel = pixel
        self.currentPixelPos = pos
        self.pixelLabel.config(text=str(pos))
        return

    # Uses grid geometry manager to display pixels of the current image

    def renderImage(self):
        count = 0
        for i in range(self.imgSizeY):
            for j in range(self.imgSizeX):
                self.pixel[self.imageNum][count].grid(row=i, column=j,
                        sticky='nswe')
                count += 1
        return

    # Uses grid geometry manager to hide the pixel of the current image

    def unrenderImage(self):
        count = 0
        for i in range(self.imgSizeY):
            for j in range(self.imgSizeX):
                self.pixel[self.imageNum][count].grid_forget()
                count += 1
        return

    # Displays the next image

    def nextImage(self):
        self.unrenderImage()

        # restore colour of previous selected pixel

        if self.currentPixel != None:
            self.currentPixel.config(bg=self.currentPixel['highlightcolor'
                    ])
        self.imageNum = (self.imageNum + 1) % self.setSize
        self.renderImage()
        self.currentPixel = None
        self.currentPixelPos = None
        self.pixelLabel.config(text='No Pixel Selected')
        return

    # Displays the previous image

    def prevImage(self):
        self.unrenderImage()

        # restore colour of previous selected pixel

        if self.currentPixel != None:
            self.currentPixel.config(bg=self.currentPixel['highlightcolor'
                    ])
        self.imageNum = (self.imageNum - 1) % self.setSize
        self.renderImage()
        self.currentPixel = None
        self.currentPixelPos = None
        self.pixelLabel.config(text='No Pixel Selected')
        return
